---
layout: post
category: book
---
## 六、虚拟机类加载机制

Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称为虚拟机的类加载机制。

### 6.1 类加载时机

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载、验证、准备、卸载、解析、初始化、使用、卸载七个阶段，其中验证、准备、解析三个部分统称为连接：

 ![img](https://gitee.com/tostringcc/blog/raw/master/2020/16f7f231e93b9c0c.jpg) 

《Java 虚拟机规范》严格规定了有且只有六种情况必须立即对类进行初始化：

1. 遇到 

   ```
   new
   ```

   、 

   ```
   getstatic
   ```

   、 

   ```
   putstatic
   ```

   、 

   ```
   invokestatic
   ```

    这四条字节码指令，如果类型进行过初始化，则需要先触发其进行初始化，能够生成这四条指令码的典型 Java 代码场景有：

   - 使用 `new` 关键字实例化对象时；
   - 读取或设置一个类型的静态字段时（被 final 修饰，已在编译期把结果放入常量池的静态字段除外）；
   - 调用一个类型的静态方法时。

2. 使用 `java.lang.reflect` 包的方法对类型进行反射调用时，如果类型没有进行过初始化、则需要触发其初始化；

3. 当初始化类时，如发现其父类还没有进行过初始化、则需要触发其父类进行初始化；

4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；

5. 当使用 JDK 7 新加入的动态语言支持时，如果一个 `java.lang.invoke.MethodHandle` 实例最后解析的结果为 `REF_getStatic` ， `REF_putStatic` ， `REF_invokeStatic` ， `REF_newInvokeSpecial` 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化；

6. 当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那么该接口要在其之前被初始化。

### 6.2 类加载过程

#### 1. 加载

在加载阶段，虚拟机需要完成以下三件事：

- 通过一个类的全限定名来获取定义此类的二进制字节流 ；
- 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构；
- 在内存中生成一个代表这个类的 `java.lang.Class` 对象，作为方法区这个类的各种数据的访问入口。

《Java 虚拟机规范》并没有限制从何处获取二进制流，因此可以从 JAR 包、WAR 包获取，也可以从 JSP 生成的 Class 文件等处获取。

#### 2. 验证

这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，从而保证这些信息被当做代码运行后不会危害虚拟机自身的安全。验证阶段大致会完成下面四项验证：

- **文件格式验证**：验证字节流是否符合 Class 文件格式的规范；
- **元数据验证**：对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java 语言规范》的要求（如除了 `java.lang.Object` 外，所有的类都应该有父类）；
- **字节码验证**：通过数据流分析和控制流分析，确定程序语义是合法的，符合逻辑的（如允许把子类对象赋值给父类数据类型，但不能把父类对象赋值给子类数据类型）；
- **符号引用验证**：验证类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。如果无法验证通过，则会抛出一个`java.lang.IncompatibleClassChangeError` 的子类异常，如 `java.lang.NoSuchFieldError` 、 `java.lang.NoSuchMethodError` 等。

#### 3. 准备

准备阶段是正式为类中定义的变量（即静态变量，被 static 修饰的变量）分配内存并设置类变量初始值的阶段。

#### 4. 解析

解析是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程：

- **符号引用**：符号引用用一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
- **直接引用**：直接引用是指可以直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。

整个解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这 7 类符号引用进行解析。

#### 5. 初始化

初始化阶段就是执行类构造器的 `<clinit>()` 方法的过程，该方法具有以下特点：

- `<clinit>()` 方法由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生，编译器收集顺序由语句在源文件中出现的顺序决定。
- `<clinit>()` 方法与类的构造器函数（即在虚拟机视角中的实例构造器 `<init>()`方法）不同，它不需要显示的调用父类的构造器，Java 虚拟机会保证在子类的 `<clinit>()` 方法执行前，父类的 `<clinit>()` 方法已经执行完毕。
- 由于父类的 `<clinit>()` 方法先执行，也就意味着父类中定义的静态语句块要优先于子类变量的赋值操作。
- `<clinit>()` 方法对于类或者接口不是必须的，如果一个类中没有静态语句块，也没有对变量进行赋值操作，那么编译器可以不为这个类生成 `<clinit>()` 方法。
- 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 `<clinit>()` 方法。
- Java 虚拟机必须保证一个类的 `<clinit>()` 方法在多线程环境中被正确的加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的 `<clinit>()` 方法，其他线程都需要阻塞等待。

### 6.3 类加载器

能够通过一个类的全限定名来获取描述该类的二进制字节流的工具称为类加载器。每一个类加载器都拥有一个独立的类名空间，因此对于任意一个类，都必须由加载它的类加载器和这个类本身来共同确立其在 Java 虚拟机中的唯一性。这意味着要想比较两个类是否相等，必须在同一类加载器加载的前提下；如果两个类的类加载器不同，则它们一定不相等。

### 6.4 双亲委派模型

从 Java 虚拟机角度而言，类加载器可以分为以下两类：

- **启动类加载器**：启动类加载器（Bootstrap ClassLoader）由 C++ 语言实现（以 HotSpot 为例），它是虚拟机自身的一部分；
- **其他所有类的类加载器**：由 Java 语言实现，独立存在于虚拟机外部，并且全部继承自 `java.lang.ClassLoader` 。

从开发人员角度而言，类加载器可以分为以下三类：

- **启动类加载器 (Boostrap Class Loader)**：负责把存放在 `<JAVA_HOME>\lib` 目录中，或被 `-Xbootclasspath` 参数所指定的路径中存放的能被 Java 虚拟机识别的类库加载到虚拟机的内存中；
- **扩展类加载器 (Extension Class Loader)**：负责加载 `<JAVA_HOME>\lib\ext` 目录中，或被 `java.ext.dirs` 系统变量所指定的路径中的所有类库。
- **应用程序类加载器 (Application Class Loader)**：负责加载用户类路径（ClassPath）上的所有的类库。

JDK 9 之前的 Java 应用都是由这三种类加载器相互配合来完成加载：

 ![img](https://gitee.com/tostringcc/blog/raw/master/2020/16f7f231ecf573e9.jpg) 

上图所示的各种类加载器之间的层次关系被称为类加载器的 “双亲委派模型”，“双亲委派模型” 要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，需要注意的是这里的加载器之间的父子关系一般不是以继承关系来实现的，而是使用组合关系来复用父类加载器的代码。

双亲委派模型的工作过程如下：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。基于双亲委派模型可以保证程序中的类在各种类加载器环境中都是同一个类，否则就有可能出现一个程序中存在两个不同的 `java.lang.Object` 的情况。

### 6.5 模块化下的类加载器

JDK 9 之后为了适应模块化的发展，类加载器做了如下变化：

- 仍维持三层类加载器和双亲委派的架构，但扩展类加载器被平台类加载器所取代；
- 当平台及应用程序类加载器收到类加载请求时，要首先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载；
- 启动类加载器、平台类加载器、应用程序类加载器全部继承自 `java.internal.loader.BuiltinClassLoader` ，BuiltinClassLoader 中实现了新的模块化架构下类如何从模块中加载的逻辑，以及模块中资源可访问性的处理。

 ![img](https://gitee.com/tostringcc/blog/raw/master/2020/16f7f235743b552b.jpg) 

## 七、程序编译

### 7.1 编译器分类

- **前端编译器**：把 `*.java` 文件转变成 `.class` 文件的过程；如 JDK 的 Javac，Eclipse JDT 中的增量式编译器。
- **即使编译器**：常称为 JIT 编译器（Just In Time Complier），在运行期把字节码转变成本地机器码的过程；如 HotSpot 虚拟机中的 C1、C2 编译器，Graal 编译器。
- **提前编译器**：直接把程序编译成目标机器指令集相关的二进制代码的过程。如 JDK 的 jaotc，GUN Compiler for the Java（GCJ），Excelsior JET 。

### 7.2 解释器与编译器

在 HotSpot 虚拟机中，Java 程序最初都是通过解释器（Interpreter）进行解释执行的，其优点在于可以省去编译时间，让程序快速启动。当程序启动后，如果虚拟机发现某个方法或代码块的运行特别频繁，就会使用编译器将其编译为本地机器码，并使用各种手段进行优化，从而提高执行效率，这就是即时编译器。HotSpot 内置了两个（或三个）即时编译器：

- **客户端编译器 (Client Complier)**：简称 C1；
- **服务端编译器 (Servier Complier)**：简称 C2，在有的资料和 JDK 源码中也称为 Opto 编译器；
- **Graal 编译器**：在 JDK 10 时才出现，长期目标是替代 C2。

在分层编译的工作模式出现前，采用客户端编译器还是服务端编译器完全取决于虚拟机是运行在客户端模式还是服务端模式下，可以在启动时通过 `-client` 或 `-server` 参数进行指定，也可以让虚拟机根据自身版本和宿主机性能来自主选择。

### 7.3 分层编译

要编译出优化程度越高的代码通常都需要越长的编译时间，为了在程序启动速度与运行效率之间达到最佳平衡，HotSpot 虚拟机在编译子系统中加入了分层编译（Tiered Compilation）：

- **第 0 层**：程序纯解释执行，并且解释器不开启性能监控功能；
- **第 1 层**：使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能；
- **第 2 层**：仍然使用客户端编译执行，仅开启方法及回边次数统计等有限的性能监控；
- **第 3 层**：仍然使用客户端编译执行，开启全部性能监控；
- **第 4 层**：使用服务端编译器将字节码编译为本地代码，其耗时更长，并且会根据性能监控信息进行一些不可靠的激进优化。

以上层次并不是固定不变的，根据不同的运行参数和版本，虚拟机可以调整分层的数量。各层次编译之间的交互转换关系如下图所示：

 ![img](https://gitee.com/tostringcc/blog/raw/master/2020/16f7f23284a7116e.jpg) 

实施分层编译后，解释器、客户端编译器和服务端编译器就会同时工作，可以用客户端编译器获取更高的编译速度、用服务端编译器来获取更好的编译质量。

### 7.4 热点探测

即时编译器编译的目标是 “热点代码”，它主要分为以下两类：

- 被多次调用的方法。
- 被多次执行循环体。这里指的是一个方法只被少量调用过，但方法体内部存在循环次数较多的循环体，此时也认为是热点代码。但编译器编译的仍然是循环体所在的方法，而不会单独编译循环体。

判断某段代码是否是热点代码的行为称为 “热点探测” （Hot Spot Code Detection），主流的热点探测方法有以下两种：

- **基于采样的热点探测 (Sample Based Hot Spot Code Detection)**：采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那么就认为它是 “热点方法”。
- **基于计数的热点探测 (Counter Based Hot Spot Code Detection)**：采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是 “热点方法”。

## 八、代码优化

即时编译器除了将字节码编译为本地机器码外，还会对代码进行一定程度的优化，它包含多达几十种优化技术，这里选取其中代表性的四种进行介绍：

### 8.1 方法内联

最重要的优化手段，它会将目标方法中的代码原封不动地 “复制” 到发起调用的方法之中，避免发生真实的方法调用，并采用名为类型继承关系分析（Class Hierarchy Analysis，CHA）的技术来解决虚方法（Java 语言中默认的实例方法都是虚方法）的内联问题。

### 8.2 逃逸分析

逃逸行为主要分为以下两类：

- **方法逃逸**：当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，此时称为方法逃逸；
- **线程逃逸**：当一个对象在方法里面被定义后，它可能被外部线程所访问，例如赋值给可以在其他线程中访问的实例变量，此时称为线程，其逃逸程度高于方法逃逸。

```
public static StringBuilder concat(String... strings) {
    StringBuilder sb = new StringBuilder();
    for (String string : strings) {
        sb.append(string);
    }
    return sb; // 发生了方法逃逸
}

public static String concat(String... strings) {
    StringBuilder sb = new StringBuilder();
    for (String string : strings) {
        sb.append(string);
    }
    return sb.toString(); // 没有发生方法逃逸
}
 
```

如果能证明一个对象不会逃逸到方法或线程之外，或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可以为这个对象实例采取不同程序的优化：

- **栈上分配 (Stack Allocations)**：如果一个对象不会逃逸到线程外，那么将会在栈上分配内存来创建这个对象，而不是 Java 堆上，此时对象所占用的内存空间就会随着栈帧的出栈而销毁，从而可以减轻垃圾回收的压力。
- **标量替换 (Scalar Replacement)**：如果一个数据已经无法再分解成为更小的数据类型，那么这些数据就称为标量（如 int、long 等数值类型及 reference 类型等）；反之，如果一个数据可以继续分解，那它就被称为聚合量（如对象）。如果一个对象不会逃逸外方法外，那么就可以将其改为直接创建若干个被这个方法使用的成员变量来替代，从而减少内存占用。
- **同步消除 (Synchronization Elimination)**：如果一个变量不会逃逸出线程，那么对这个变量实施的同步措施就可以消除掉。

### 8.3 公共子表达式消除

如果一个表达式 E 之前已经被计算过了，并且从先前的计算到现在 E 中所有变量的值都没有发生过变化，那么 E 这次的出现就称为公共子表达式。对于这种表达式，无需再重新进行计算，只需要直接使用前面的计算结果即可。

### 8.4 数组边界检查消除

对于虚拟机执行子系统来说，每次数组元素的读写都带有一次隐含的上下文检查以避免访问越界。如果数组的访问发生在循环之中，并且使用循环变量来访问数据，即循环变量的取值永远在 [0，list.length) 之间，那么此时就可以消除整个循环的数据边界检查，从而避免多次无用的判断。

## 参考资料

- **主要参考自：周志明 . 深入理解Java虚拟机（第3版）. 机械工业出版社 , 2019-12 ，想要深入了解虚拟机的话，推荐阅读原书**。
- [美团技术团队 —— Java Hotspot G1 GC的一些关键技术](https://tech.meituan.com/2016/09/23/g1.html)
- [《深入理解 JAVA 虚拟机》第三版（2019.12）读书笔记](https://juejin.im/post/6844904039994359821#comment)

