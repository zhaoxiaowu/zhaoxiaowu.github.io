---
layout: post
category: 中间件
---
## 更新缓存 VS 淘汰缓存

什么是更新缓存：数据不但写入数据库，还会写入缓存

什么是淘汰缓存：数据只会写入数据库，不会写入缓存，只会把数据淘汰掉



更新缓存的优点：缓存不会增加一次miss，命中率高

淘汰缓存的优点：操作简单（如果缓存的获取比较复杂，更新缓存代价大，就倾向于淘汰缓存）



## 先操作数据库 vs 先操作缓存

> 如果系统并发量较小，那么选择先淘汰缓存的做法是比较好的。

**对于一个不能保证事务性的操作，谁先做对业务的影响较小，就谁先执行。**

**假设先写数据库，再淘汰缓存**

第一步写数据库操作成功，第二步淘汰缓存失败，则会出现DB中是新数据，Cache中是旧数据，数据不一致。

**假设先淘汰缓存，再写数据库**：第一步淘汰缓存成功，第二步写数据库失败，则只会引发一次Cache miss



> 如果并发量较大，并且缓存系统做了集群，网络极少发生抖动（也就是极大程度可以保证原子性），那么选择先操作数据库后操作缓存的做法较好。

这个更新操作就不会发生陈皓老师开篇时提到的问题。举个🌰，一个查询操作和一个更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。这样后续的查询操作就会拉取最新的数据。

并且陈皓老师也指出，Facebook的论文《[Scaling Memcache at Facebook](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.usenix.org%2Fsystem%2Ffiles%2Fconference%2Fnsdi13%2Fnsdi13-final170_update.pdf)》也使用了这个策略。这样做的目的主要是避免两个并发的写操作导致脏数据。



而关于做连接取模与使用2PC等方案保证数据一致性，个人感觉没有必要，徒增复杂性，因为涉及库存等重要的数据操作无论如何最后都要查询真实的DB，给缓存数据设置过期时间减少不一致发生的概率与存在时间即可。

**参考：**

[关于如何更新缓存的探讨](https://www.jianshu.com/p/aadb866623ef)

[缓存更新的套路](https://coolshell.cn/articles/17416.html)

[缓存架构设计细节二三事](https://www.w3cschool.cn/architectroad/architectroad-cache-architecture-design.html)

