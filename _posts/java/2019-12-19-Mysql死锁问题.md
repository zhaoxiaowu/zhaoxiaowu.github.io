---
layout: post
category: Java
---
`Deadlock found when trying to get lock`  死锁问题报错

### 死锁原因

两个或两个以上事务，资源竞争相互等待。

### Innodb死锁检测

在innodb中，参数innodb_lock_wait_timeout用来设置超时时间。

innodb还提供了wait-for graph算法来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，`wait-for graph`算法都会被触发，

检查是否出现环路，出现环路就是死锁。

### 死锁常见原因

##### 1.出现循环等待锁情况。

##### 2.相同表记录行锁冲突

##### 3.不同索引锁冲突

 这种情况比较隐晦，事务A在执行时，除了在二级索引加锁外，还会在聚簇索引上加锁，在聚簇索引上加锁的顺序是[1,4,2,3,5]，而事务B执行时，只在聚簇索引上加锁，加锁顺序是[1,2,3,4,5]，这样就造成了死锁的可能性。

##### 4.gap锁冲突

### 如何避免死锁

1.以固定顺序访问表和行

2.大事务拆小

3.在同一事物尽可能一次锁定所有资源

4.降低隔离级别，有RR调整为RC,可以避免gap锁造成的死锁

5.为表添加合理的索引，防止行锁变为表锁

### 如何定位死锁成因

1.通过日志找出对应SQL

2.确定隔离级别

3.执行下show InnoDB STATUS看看最近死锁的日志。

**参考：**

[[mysql死锁问题分析](https://www.cnblogs.com/tartis/p/9366574.html)](https://www.cnblogs.com/tartis/p/9366574.html)